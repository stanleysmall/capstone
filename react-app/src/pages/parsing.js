import {openEndedQuestionList} from "./vars";

 /*
    Arguments: 
        survey: a surveyJS object created using the surveyJSON var from vars.js which has been completed

    Populates the evaltemplate object with data in an API friendly format:
    
    {  "URL": str,
        "instructor": str,
        "participants": [{"name": str,
                            "address": str}, ...],
        "questions": [{"ID": int,
                        "helpText": str,
                        "mandatory": bool,
                        "group": str,
                        "type": str,
                        "text": str}, ...],
        "name": str,
        tag name 2: str,
        tag name 3: str, ...}

*/
export const formatSurvey = (survey) =>
{

    //Stores correctly formatted data to be pushed to database
    var evalTemplate = {
    }

    //endpoint requires URL which is not used, just give a false one
    evalTemplate.URL = "blank.com"

    //Generate instructor full name
    evalTemplate.instructor = survey.data.instructorFirst + " " + survey.data.instructorLast

    //Parse participants CSV
    evalTemplate.participants = generateParticipants(survey.data.classRoll);

    //Parse Questions
    evalTemplate.questions = generateQuestions(survey.data);

    //Generate Evaluation Name
    evalTemplate.name = survey.data.courseDesignator + "" + survey.data.courseNumber +
    ":" + survey.data.courseSection + " " + survey.data.semesterYear;

    //Grab all the tags from the survey as they correspond 1 to 1 with the formatted eval template
    evalTemplate.courseDesignator = survey.data.courseDesignator;
    evalTemplate.courseNumber = survey.data.courseNumber;
    evalTemplate.courseSection = survey.data.courseSection;
    evalTemplate.courseTitle = survey.data.courseTitle;
    evalTemplate.semesterYear = survey.data.semesterYear;
    evalTemplate.facultyUnit = survey.data.facultyUnit;
    evalTemplate.college = survey.data.college;
    evalTemplate.university = survey.data.university;
    evalTemplate.instructorFirst = survey.data.instructorFirst;
    evalTemplate.instructorLast = survey.data.instructorLast;
    evalTemplate.instructorEmail = survey.data.instructorEmail;
    evalTemplate.instructorPhone = survey.data.instructorPhone;
    evalTemplate.adminName = survey.data.adminName;
    evalTemplate.adminEmail = survey.data.adminEmail;
    evalTemplate.beginDate = survey.data.beginDate;
    evalTemplate.closeDate = survey.data.closeDate;
    evalTemplate.reminderTime = survey.data.reminderTime;

    //email_invite          <------------------------------------------ breaks naming convention, required tag name by API
    evalTemplate.email_invite = survey.data.initialEmail;
    //email_reminder        <------------------------------------------ breaks naming convention, required tag name by API
    evalTemplate.email_reminder = survey.data.reminderEmail;

    //-------------------------------------------------TODO-------------------------------------------------------
    //description
    //welcometext
    //endtext
    //email_register
    //email_confirm

    
    console.log("formatted: " + JSON.stringify(evalTemplate,null,2));

    return evalTemplate;

}

/*
    Arguments:
        surveyData: a JSON object of the data generated by the survey which takes user input

    Returns:
        A list of questions from the users input in the form:
            [{"ID": int,
                "helpText": str,
                "mandatory": bool,
                "group": str,
                "type": str,
                "text": str}, ...]
*/
const generateQuestions = (surveyData) =>
{
    //List of questions that will be returned after parsing data from the users input
    var questions = [];

    var questionID = 1;
    var currentGroup = "";
    var currentDataSet;

    //parse course questions
    currentGroup = "Course Questions"
    currentDataSet = surveyData.courseQuestions;
    questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID)

    //parse assesment questions
    currentGroup = "Assesment Questions"
    currentDataSet = surveyData.assesmentQuestions;
    questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID)

    //parse instructor questions
    currentGroup = "Instructor Questions"
    currentDataSet = surveyData.instructorQuestions;
    questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID)

    //parse lab questions
    if(surveyData.includeLabQuestions === "true")
    {
        currentGroup = "Lab Questions"
        currentDataSet = surveyData.labQuestions;
        questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID) 
    }

    //parse online questsions
    if(surveyData.includeOnlineQuestions === "true")
    {
        currentGroup = "Online Questions"
        currentDataSet = surveyData.onlineQuestions;
        questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID) 
    }
    
    //parse teaching assitant questions
    if(surveyData.includeTeachingAssistantQuestions === "true")
    {
        currentGroup = "Teaching Assistant Questions"
        currentDataSet = surveyData.teachingAssitantQuestions;
        questionID = parseQuestionSet(currentGroup, currentDataSet, questions, questionID) 
    }

    //parse open ended questions
    currentGroup = "Open Ended Questions"
    currentDataSet = surveyData.openEndedQuestions;
    parseQuestionSet(currentGroup, currentDataSet, questions, questionID) 

    //parse additional questions
    //--------------------------------TODO-----------------------------
    
    return questions;
}

/*
    Arguments:
        currentGroup: Name of the current group of questions you are parsing
        currentDataSet: Data set of user input that is currently being procesed
        questions: List of questions to append new questions to
        questionID: Int representing the ID of the current question

    Parses the user input in currentDataSet and appends questions to the questions list
    in the form:

    [{"ID": int,
    "helpText": str,
    "mandatory": bool,
    "group": str,
    "type": str,
    "text": str}, ...]
*/
const parseQuestionSet = (currentGroup, currentDataSet, questions, questionID) =>
{
    var question = {
        "ID" : "",
        "helpText" : "",
        "mandatory" : "",
        "group" : "",
        "type" : "",
        "text" : ""
    }

    for(var property in currentDataSet)
    {
        if(currentDataSet.hasOwnProperty(property))
        {   
            //If the question is included
            if(currentDataSet[property].Inclusion !== "Do not include")
            {
                //parse if the question is mandatory
                if(currentDataSet[property].Inclusion === "Include")
                {
                    question.mandatory = false;
                }
                else if (currentDataSet[property].Inclusion === "Mandatory")
                {
                    question.mandatory = true;
                }

                question.ID = questionID;
                question.group = currentGroup;
                
                //question type 5 = 5 point choice, T = text question
                //check if it is on the list of open ended questions included in vars.js
                if(openEndedQuestionList.indexOf(property) >= 0)
                {
                    question.type = "T";
                }
                else
                {
                    question.type = "5";
                }

                //Help text if it is a 5 poing question, no help text if it is open ended.
                if(question.type === "5")
                {
                    question.helpText = "1 is low, 5 is high";
                }
                else{
                    question.helpText = "";
                }
                
                //The question text is the preoprty in the JSON we are itterating over
                question.text = property;

                //Deep copy the question
                var temp = JSON.parse(JSON.stringify(question));

                //Push the deep copy to the list of questions
                questions.push(temp);

                questionID++;
            }
        }
    }
    return questionID;
}

    /*
    Arguments: 
        classRoll: String of participants in the form of first,last,email seperated by new lines or commas

    Returns:
        List of participants in the form:
        [{
        "name" : "",
        "address" : ""
        }, ...]
*/
const generateParticipants = (classRoll) =>
{
    //Replace new line characters with commas
    classRoll = classRoll.replace(/\n/g,",");
    
    //split the classroll into an array in order of first,last,email
    var split = classRoll.split(",");
    
    //Variables used to construct particpants
    var count = 0;
    var fullname = "";

    //template for how participants need to be formatted
    //used when building participants to appent to the participants list
    var participant = {
        "name" : "",
        "address" : ""
    }
    //list of participants to be returned
    var participants = [];

    //Loop though the array of first,last,email
    for(var i = 0; i <split.length; i++)
    {
        //If first index for current participant set fullname = firstname
        if(count === 0)
        {
            fullname = split[i];
            count ++;
        }
        //Else if second index for current participant append a space and last name to fullname
        else if(count === 1)
        {
            fullname += " ";
            fullname += split[i];
            count ++;
        }
        //Else if third index for current participant populate participant with fullname and address
        else if(count === 2)
        {
            participant.name = fullname;
            participant.address = split[i];
            
            //Deep copy the participant
            var temp = JSON.parse(JSON.stringify(participant));

            //Push the deep copy to the list of participants
            participants.push(temp);

            //start over on the next participant
            count = 0;
        }

    }
    return participants;
}



    /*
    Arguments:
        evaluation: an evaluation object you wish to pre populate the fields with in the form:
        surveyJSON: the surveyJS JSON you want to load the evaluation into

    {  "URL": str,
        "instructor": str,
        "participants": [{"name": str,
                            "address": str}, ...],
        "questions": [{"ID": int,
                        "helpText": str,
                        "mandatory": bool,
                        "group": str,
                        "type": str,
                        "text": str}, ...],
        "name": str,
        tag name 2: str,
        tag name 3: str, ...}

    returns: 
        A surveyJSON populated with all information from the passed evaluation


    Loads all aspects of the passed eval into the new form
    except for the semester/year, begin/end date, and class roll
*/
export const loadEvaluation = (evaluation, surveyJSON) =>
{
    //store values to populate first page in an array
    var newValues = [
                    evaluation.courseDesignator,
                    evaluation.courseNumber,
                    evaluation.courseSection,
                    evaluation.courseTitle,
                    evaluation.semesterYear,                             //Don't populate the semester/year
                    evaluation.facultyUnit,
                    evaluation.college,
                    evaluation.university,
                    evaluation.instructorFirst,
                    evaluation.instructorLast,
                    evaluation.instructorEmail,
                    evaluation.instructorPhone,
                    evaluation.adminName,
                    evaluation.adminEmail,
                    evaluation.beginDate,                             //Don't populate the being/end date
                    evaluation.closeDate,
                    evaluation.reminderTime      
    ]

    //Populate the surveyJSON with default values for the first page
    for(var i = 0; i < newValues.length; i++)
    {
        surveyJSON.pages[0].elements[i].defaultValue = newValues[i];
    }

    //Indices of question sets in the second page elements
    var questionSets = [0,1,2,4,6,8,9];

    //Set default values of all questions on page 2 to do not include
    for(i = 0; i < questionSets.length; i++)
    {
        //Store the currentDataSet, for readability
        var currentDataSet = surveyJSON.pages[1].elements[questionSets[i]].defaultValue;

        //For every property set it to not include
        for(var property in currentDataSet)
        {
            if(currentDataSet.hasOwnProperty(property))
            { 
                currentDataSet[property].Inclusion = "Do not include";
            }
        }
    }

    //Used for indexing into the surveyJSON
    var questionSet = 0;
    var currentQuestion;

    //Populate the surveyJSON with default values for the second page
    for(i = 0; i < evaluation.questions.length; i++)
    {
        //store the text of the question
        currentQuestion = evaluation.questions[i].text;

        //Get the set of questions that the current question we are looking at is from
        switch(evaluation.questions[i].group)
        {
            case "Instructor Questions": 
                questionSet = 0;
                break;
            case "Course Questions": 
                questionSet = 1;
                break;
            case "Assesment Questions": 
                questionSet = 2;
                break;
            case "Lab Questions": 
                questionSet = 4;
                //If a lab question exists than set the value of was there a lab component to true
                surveyJSON.pages[1].elements[3].defaultValue = "true";
                break;
            case "Teaching Assistant Questions":
                questionSet = 6;
                //If a teaching assistant question exists than set the value of was there a teaching assistent to true
                surveyJSON.pages[1].elements[5].defaultValue = "true";
                break;
            case "Online Questions":
                questionSet = 8;
                //if an online question exists than set the value of was there an online component to true
                surveyJSON.pages[1].elements[7].defaultValue = "true";
                break;
            case "Open Ended Questions":
                questionSet = 9;
                break;
            default:
                questionSet = -1
                break;
        }

        //If the question was mandatory set its corresponding default value to manditory
        if(evaluation.questions[i].mandatory)
        {
            surveyJSON.pages[1].elements[questionSet].defaultValue[currentQuestion].Inclusion = "Mandatory"
        }
        //Else set default value to Include
        else
        {
            surveyJSON.pages[1].elements[questionSet].defaultValue[currentQuestion].Inclusion = "Include"
        }
    }

    //Populate the surveyJSON with default values for the third page
    surveyJSON.pages[2].elements[1].defaultValue = evaluation.email_invite;
    surveyJSON.pages[2].elements[3].defaultValue = evaluation.email_reminder;

    //Turn classroll from eval into CSV format
    var classRoll = "";
    for(i = 0; i < evaluation.participants.length; i ++)
    {
        var names = evaluation.participants[i].name.split(" ");
        classRoll = classRoll + names[0] + "," + names[1] + "," + evaluation.participants[i].address + "\n";
    }

    surveyJSON.pages[2].elements[0].defaultValue = classRoll;

    return surveyJSON;
}